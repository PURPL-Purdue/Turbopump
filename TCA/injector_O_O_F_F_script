import numpy as np
import math
import yaml
import matplotlib.pyplot as plt
from spicy import optimize
import csv

with open(r'/Users/dl/Documents/GitHub/Turbopump/TCA/TCA_params.yaml') as file: ##CHANGED FOR DANIEL
		tca_params = yaml.safe_load(file)

# == Conversion between units ==
psi_into_pa = 6894.76 # Convert psi -> Pascal
meters_into_inches = 39.37 # Convert meters -> inches
degrees_into_rad = np.pi/180 # Convert degrees -> radians
lbm_into_kg = 0.453592 # Convert lbm -> kg
lbf_into_newton = 4.44822 # Convert lbf -> Newton
g0 = 9.81 # m/s^2

# == Desing Parameters (Change as needed) == 
mdot = tca_params['tca_throat_choked_flow']*lbm_into_kg #Total propellant mass flow rate [kg/s]
OF_Ratio = tca_params['oxidizer_fuel_ratio'] #Mixture ratio O/F 
rho_rp1 = 810 #RP1 Density [kg/m^3] at injector conditions
rho_lox = 1141 #LOX Density [kg/m^3] at injector conditions
Cd = tca_params['discharge_coefficient'] #Discharge coefficient

Pc = tca_params['tca_chamber_pressure']*psi_into_pa #Chamber stagnation pressure [Pa]
Pin = tca_params['incoming_pressure']*psi_into_pa #injector inlet pressure [Pa]
delta_P = Pin - Pc #Pressure drop across injector [Pa]


Length_chamber = tca_params['tca_chamber_length']/meters_into_inches #Combustion chamber length [m]
CombDiam = tca_params['tca_chamber_diameter']/meters_into_inches #chamber inner diameter [m]
throat_diameter = tca_params['tca_throat_diameter']/meters_into_inches #throat diameter [m]


# == Injector Geometry Parameters ==
wall_thickness = tca_params['injector_plate_thickness'] #[m]
impinge_fraction = tca_params['impinge_fraction'] #streams will impinge at 2.2% of chamber length
distance_between_holes = tca_params['distance_between_holes'] #[m]
marginWall = tca_params['marginWall'] #clearance from outer RP1 jet to wall [m]
pairSpacing = tca_params['pairSpacing'] #spacing between mid-radii of FO pairs [m]

#MANIFOLD DESING
h_manifold = tca_params['h_manifold'] #m
dpFracMani = 0.09 #dp manifold ~9% of injector dp

#Friction factors and local loss coefficients
fOx = 0.01 #darcy friction factor LOX
fRP1 = 0.01 #darcy friction factor RP1
KOx = 1 #lumped local loss K LOX
KRP1 = 1 #lumped local loss K RP1
NinletsOx = 1 #number of LOX manifold inlets
NinletsRP1 = 1 #number of RP1 manifold inlets

# == Hole-Size Calculations ==
mdot_kero = mdot/(1+OF_Ratio) #Fuel mass flow (RP-1)
mdot_lox = mdot*OF_Ratio/(1+OF_Ratio) #Oxidizer mass flow (LOX)

# === Injector element layout (design description) ===  
#The injector uses a doublet impinging pair at the center of the faceplate.
#Around the center, three concentric rings of holes distribute additional fuel/oxidizer 
#The central two holes form the primary impinging element (RP1 + LOX)
#The outer ring of fuel holes is directed toward the chamber wall to provide film cooling.

num_holes_rp1_inj = tca_params['injector_number_of_holes_rp1'] #number of RP1 holes in injector faceplate
num_holes_lox_inj = tca_params['injector_number_of_holes_lox'] #number of LOX holes in injector faceplate

Nrings = 2 #Number of hole rings per propellant

#This function distribute the total propellant mass flow among a specific set of injector holes
    #mdot_propellant --- the total mass flow rate of that propelant [kg/s]
    #number_holes --- number of holes of this specific type 
    #total_number_of_holes --- total number of holes that share the propellant flow
def mdot_prop(mdot_propellant, number_holes, total_number_of_holes):
    mdot_propel = mdot_propellant * number_holes/(total_number_of_holes)
    mdot_per_hole = mdot_propel/number_holes
    return mdot_propel, mdot_per_hole

#This function computes the required injector orifice diameter for a given mass flow 
    #mdot_per_prop --- mass flow rate through this specific parth [kg/s]
    #rho --- propellant density at injector conditions
    #delta_pressure --- pressure drop across the orifice [psi]
    #number_holes --- number of identical holes sharing this mass flow
def diameter(mdot_per_prop, rho, delta_pressure, number_holes): 
    #following the orifice flow model, and solving for the Area
    Total_area = mdot_per_prop/(Cd*np.sqrt(2*rho*delta_pressure*psi_into_pa))
    Area_per_hole = Total_area/number_holes
    d_hole = 2*np.sqrt(Area_per_hole/np.pi) 
    return d_hole

#This function computes the ideal jet exit velocity through an injector orifice using Bernoulli's 
#incompressible flow relation with a pressure drop
    #delta_pressure_injector --- pressure drop across the injector 
    #rho --- propellant density at injector conditions [kg/m^3]
def velocity(delta_pressure_injector, rho):
    velocity = np.sqrt((2*delta_pressure_injector)/rho)
    return velocity

#This function determines the oxidizer injection angle (theta_ox) for a doublet impinging injector
#such that the post-impingement spray sheet forms a desired angle beta with respect to the chamber 
#axis, for a given fuel injection angle theta_fuel. 

    """
    Parameters:
    mdot_fuel: Mass flow rate of the fuel jet [kg/s]
    mdot_ox: Mass flow rate of the oxidizer jet [kg/s]
    v_fuel: Exit velocity of the fuel jet [m/s]
    v_ox: Exit velocity of the oxidizer jet [m/s]
    theta_fuel: Fuel injection angle measured from the chamber axis [deg]
    beta_target_deg: Desired resultant spray angle after the impingement [deg]
    theta_ox_min_deg, theta_ox_max_deg: Search range for oxidizer injection angle [deg]
    dtheta_deg: angular resolution of the brute-force sweep [deg]
    
    Method:
    - Momentum of each jet is decomposed into X and Y components. Fuel momentum is taken
      with negative X component (pointing inward). Oxidizer momentum uses positive X
      direction.
    - For each candidate oxidizer angle theta_ox in the search range:
        * Convert theta_fuel and theta_ox to radians.
        * Resolve each jet momentum into X/Y components (X lateral, Y axial):
              p_f = ( -P_f * sin(theta_f),  P_f * cos(theta_f) )
              p_ox = ( P_ox * sin(theta_ox), P_ox * cos(theta_ox) )
          (fuel is taken pointing inward).
        * Sum both vectors to obtain the resultant momentum:
              M = p_f + p_ox = (Mx, My)
        * Compute the sheet angle:
              beta_res = atan2(Mx, My)
        * Evaluate the error |beta_res âˆ’ beta_target| and keep the angle
          that minimizes this error.
    - The function returns the best beta_res (in degrees) and the
      corresponding theta_ox (in degrees).

    Notes:
    This model assumes planar (2-D) impingement and neglects droplet breakup physics    
    No viscous losses or jet spreading are included: pure momentum geometry only
    """
def solve_thetas(mdot_fuel, mdot_ox, v_fuel, v_ox, theta_fuel, beta_target_deg, 
                 theta_ox_min_deg=5.0, theta_ox_max_deg=80.0, dtheta_deg=0.05):
    theta_f_rad = theta_fuel*degrees_into_rad
    beta_target = beta_target_deg*degrees_into_rad
    p_f = mdot_fuel * v_fuel
    p_ox = mdot_ox * v_ox
    best_err = 1e12
    best_theta_ox_deg = None
    best_beta_deg = None 
    theta_ox_deg = theta_ox_min_deg
    while theta_ox_deg <= theta_ox_max_deg:
        theta_ox_rad = theta_ox_deg*degrees_into_rad
        px = p_ox*np.sin(theta_ox_rad) - p_f*np.sin(theta_f_rad)
        py = p_ox*np.cos(theta_ox_rad) + p_f*np.cos(theta_f_rad)
        R = px/py
        beta_res = np.arctan(R)
        err = abs(beta_res - beta_target)
        if err < best_err:
            best_err = err
            best_theta_ox_deg = theta_ox_deg
            best_beta_deg = beta_res/degrees_into_rad
        theta_ox_deg += dtheta_deg
    return best_beta_deg, best_theta_ox_deg

#This function computes the geometric relationships of a doublet impinging injection:
"""
Parameters:
Lc: combustion chamber length [mm]
impingement_fraction: Fraction of the Lc where the jets are intended to collide 
theta_fuel_deg: Fuel jet angle relative to the vertical [deg]
theta_ox_deg: oxidizer jet angle relative to the vertical [deg]
Notes:
- Assumes straight, ballistic jets with small lateral deflection.
- Suitable for preliminary injector geometry sizing.
"""
def compute_spacing_doublet(Lc, impingement_fraction, theta_fuel_deg, theta_ox_deg):
    #compute axial impingement location
    z_imp = Lc *impingement_fraction
    #converting jet angles into radians
    theta_f = theta_fuel_deg*degrees_into_rad
    theta_ox = theta_ox_deg*degrees_into_rad
    #Lateral displacement of each jet at the impingement plane:
    # x = z * tan(theta)
    d_imp_f = z_imp * (np.tan(theta_f))
    d_imp_ox = z_imp * (np.tan(theta_ox))
    #required injector-to-injector spacing for the jets to meet at z_imp
    d_fo = z_imp * (np.tan(theta_f) + np.tan(theta_ox))
    return z_imp, d_imp_f, d_imp_ox, d_fo

def dist(thickness, theta):
    theta_rad = theta*degrees_into_rad
    dist = thickness*(np.tan(theta_rad))
    return dist

def max_mixing_ratio(rho_fuel, rho_ox, mdot_fuel, mdot_ox):
    M = 1 #M=1 for 1-on-1 unlike impingement
    MME = M*(rho_ox/rho_fuel * (mdot_ox/mdot_fuel)**2)**0.7
    return MME

def design_manifold(d_orifice, n_orifices, h, rho, m_dot):
    #Total exit area (orifices):
    A_exit = n_orifices * (np.pi*(d_orifice**2)/4)
    #required manifold cross-sectional area:
    #based on the 4:1 rule for pressure uniformity
    req_manifold_area = 4 * A_exit
    #geometry with rounded corners (r = h/4)
    r = h/6
    #area loss at the 4 corners compared to a perfect rectangle
    corner_area_loss = (r**2)*(4 - np.pi)
    w = (req_manifold_area + corner_area_loss)/h
    #manifold internal velocity
    v = m_dot/(rho*req_manifold_area)
    return A_exit, req_manifold_area, h, w, r, v

def calculate_manifold_pressure_drop(w, h, r, length, rho, mu, mdot, epsilon = 0.015):
    area = w*h - (4 - np.pi)*(r**2)
    perimeter = 2*(w + h - 4*r) + 2*np.pi*r
    #hydraulic diameter
    Dh = (4*area/perimeter)
    velocity = mdot/(rho*area)
    #reynolds number
    Re = (rho*velocity*Dh)/mu
    #friction factor (using the Haaland equation)
    if Re > 2300:
        rel_roughness = (epsilon/1000)/Dh
        f_inv_sqrt = -1.8 * np.log10(((rel_roughness/3.7)**1.11) + (6.9/Re))
        f = (1/f_inv_sqrt)**2
    else:
        f = 64/Re
    delta_P = f * (length/Dh) * (rho*velocity**2)/2
    delta_P_psi = delta_P / psi_into_pa
    return delta_P_psi


